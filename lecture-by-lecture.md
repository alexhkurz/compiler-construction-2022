# Lecture by Lecture  

*Excursions* are not part of the core of this course but recommended for general background.

**Useful Links:**
- [Finite State Machine Designer](https://www.cs.unc.edu/~otternes/comp455/fsm_designer/)  
- [RegExp Visualiser](https://www.youtube.com/watch?v=ImnZRGCwBrY)  

## Part 1: Lexing, Finite Automata, Regular Expressions

In the first week we find that automata are a good specification language to specify algorithms searching for patterns in text.

- L1.1: [Searching for Strings](https://hackmd.io/@alexhkurz/Sk555wUlu). Don't forget the [Homework](https://hackmd.io/@alexhkurz/rycnvMvgu). **Excursion:** [*Why do Java and Python not have goto statements?*](https://hackmd.io/@alexhkurz/rJ5wS-0f8), which shows how to implement automata in imperative languages with and without goto.

- L1.2: [Introduction to Automata and Haskell](https://hackmd.io/@alexhkurz/HylLKujCP). Practice what you have learned with this [Homework](homework-1.2.md).

In the second week we go one level up, from automata as a specification language for search algorithms to regular expressions as a specification language for automata (and languages).

- L2.1: [Composing Automata (with Homework)](https://hackmd.io/@alexhkurz/ryV_FU7XI).

- L2.2: [Regular Expressions](https://hackmd.io/@alexhkurz/HkoNj8mmU) ... [Homework](https://hackmd.io/@alexhkurz/S1EVYe7bO) ...  

- L3.1: We reviewed the NFAs and regular expressions for the languages of Exercises 2.3.4 and 2.5.3.  We looked at the conversion of NFA to DFA in the [Introduction to Automata and Haskell](https://hackmd.io/@alexhkurz/HylLKujCP). See the highlighted assessed homework in there.

<!--  homework from previous years at https://hackmd.io/@alexhkurz/HJ1BAFYbd -->

- L3.2: We went through the monad parts of the [Introduction to Automata and Haskell](https://hackmd.io/@alexhkurz/HylLKujCP) (look for the sections on partial DFAs and on NFAs). I also link a writeup from last semester, [a very short introduction to monads](https://hackmd.io/@alexhkurz/ByD5fgecY), but it contains more on monads than we covered today (recommended as background).

This finishes what I consider the most important aspects of DFA, NFA, and regular expressions: **(1)** How to use DFA to search for/recognise patterns of strings (=languages) in a text. **(2)** How to use regular expressions to specify languages. **(3)** How to translate regular expressions to NFA and how to translate NFA to DFA. To summarize:

        reg.exp. ~> NFA ~> DFA ~> code

If we had time the next steps in the story of finite automata would be the following. **(a)** For every DFA there is a regular expression. This completes the proof the famous Kleene theorem that regular expressions and finite automata are equivalent in the sense that they recognise the same languages (called regular languages). **(b)** For every DFA there is an equivalent minimal DFA. This is important as the minimal DFA is the most efficient implementation (in terms of space) of a regular language. 

## Part 2: Parsing and Context-Free Grammars

- L4.1: [Assignment 1](https://hackmd.io/@alexhkurz/HJ4KjezfO).

- L4.2: [Introduction to Shift-Reduce Parsing](https://hackmd.io/@alexhkurz/rk5PsF2EI)

- L5.1: We went into details about the homework on concrete and abstract syntax trees. Regular expressions and DFAs cannot recognize balanced parentheses, but CFGs and PDAs can (which, in in turn, cannot verify that variables are declared before they are used is outside the scope).

- L5.2: Introduction to [Shift/reduce and reduce/reduce conflicts](https://hackmd.io/@alexhkurz/SJx6T5R48) and the  [LALR(1) parser](https://hackmd.io/@alexhkurz/SJ4sbGyrU) generated by BNFC/Happy. 

- L6.1: Lab on how to parse the third test file`med.cc`. A note on [List Notation in BNFC](https://hackmd.io/@alexhkurz/Bkbb3rS-c). How to [debug a grammar](https://hackmd.io/@alexhkurz/SkXrrBuSI). 

## Part 3: Type Checking

**Stocktaking:** We have covered the first three chapters of the book [Implementing Programming Languages](http://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/plt-book.pdf). This could be a good time to read through these chapters to consolidate what we learned. We will now turn to Chapter 4 of [IPL](http://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/plt-book.pdf). Reasons why type checking is important:

- The copy language is not context free.
- Compile-time errors are cheaper than run-time errors.
- Information in the types can be used to produce more efficient code.
- Types can be used to disambiguate over-loaded operations.

For us there is another one, namely that type checking can be seen as "interpretation at compile time". Everything we learn about typechecking will help us to understand interpretation better.

- L6.2:  Working towards Assignment 2, the [Type Checker for CPP](http://www.grammaticalframework.org/ipl-book/assignments/assignment2/assignment2.html) (a template file and detailed instructions will be in Canvas). For the theory, the main source is Chapter 4 of the book. *Homework:* Read Chapter 4.1 to 4.3 of [IPL](http://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/plt-book.pdf). 

- L7.1: We started with some remarks on the [the project](project.md). Then we looked at the template file for the type checker available on Canvas. We also covered Sections 4.4-4.5 of the book. 

- L7.2: Sections 4.6-4.8 from the book. Read these sections carefully and prepare questions for the next lecture. (Sections 4.9-4.11 are optional as this has been implemented in the template files.)

- L8.1: We went through what needs to be done for the First Deadline **(Thu, Mar 31)** for Assignment 2. As I said, feel free to use github copilot. Second Deadline will be **(Fri, April 8)**.

- L8.2: Special session with Sam Balco.

## Part 4: Interpretation

- L9.1: Chapter 5 of [IPL](http://www.cse.chalmers.se/edu/year/2012/course/DAT150/lectures/plt-book.pdf). Homework until Thursday: Read Sections 5.1-2.

- L9.2: Continued with Chapter 5. Assessed [homework for the report](https://hackmd.io/@alexhkurz/SkZELd3X5), see also Lecture 10.1. Homework until next lecture: Read Chapter 5.3.

- **Assignment 3** out. Instructions and template files are on Canvas. First deadline April 17, second deadline April 24.

- L10.1: In the lecture we looked in detail at an example of how the [interpreter executes](Sources/prooftree-interpreter.jpg) (see [here](Sources/prooftree-typechecker.jpg) for the typechecking of the same example). The pictures have some slight differences to what we have done in the lecture, so get in touch if you have any questions. <!--A [note](https://hackmd.io/@alexhkurz/rkGNCFnmq) on the operational semantics of function call.--> 


- L10.2: We worked on the interpreter assignment in class.

## Part 5: Code Generation

- L11.1: We started working on [Webassembly](https://github.com/alexhkurz/compiler-construction-2022/blob/main/lecture-code-generation-1.md), the target language for our compiler. Homework: Install the required software as specified and verify that you can run webassembly locally. Do the exercise on `ass_in_arith-short.cc`.

- L 11.2: [Compiling C to Webassembly pen-and-paper](https://github.com/alexhkurz/compiler-construction-2022/blob/master/lecture-code-generation-2.md).

